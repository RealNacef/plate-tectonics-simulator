<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Earth: A WebGPU Plate Tectonics & Mantle Convection Simulator</title>
    <style>
        /* CSS: All styles are embedded here for a single-file solution. */
        :root {
            --ui-bg-color: rgba(30, 30, 45, 0.85);
            --text-color: #f0f0f0;
            --accent-color: #00aaff;
            --slider-track-color: #444;
            --slider-thumb-color: #00aaff;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            margin: 0;
            overflow: hidden;
            color: var(--text-color);
            font-family: var(--font-family);
            background-color: #000814; /* deep space navy to avoid white flash */
        }

        canvas#bg-canvas, canvas#webgpu-canvas {
            position: fixed;
            top: 0;
            left: 0;
            outline: none;
        }

        canvas#bg-canvas {
            z-index: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none; /* background should not block UI/controls */
        }

        canvas#webgpu-canvas {
            z-index: 1; /* sits above the starfield */
            background-color: transparent !important; /* ensure no opaque fill */
        }

        #ui-container {
            position: fixed;
            top: 15px;
            left: 15px;
            background-color: var(--ui-bg-color);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            width: 320px;
            max-width: 90vw;
            transition: opacity 0.5s;
            z-index: 10; /* ensure UI is above canvases */
        }

        #ui-container h1 {
            font-size: 20px;
            margin-top: 0;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--accent-color);
            padding-bottom: 10px;
            font-weight: 500;
        }

        .ui-control {
            margin-bottom: 15px;
        }

        .ui-control label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
        }

        /* Plate speed presets */
        .speed-presets { 
            display: flex; 
            flex-wrap: wrap; 
            gap: 6px; 
            margin-top: 8px; 
        }
        .speed-presets button {
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.18);
            color: #e6e6e6;
            padding: 4px 8px;
            border-radius: 999px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.15s, border-color 0.15s;
        }
        .speed-presets button:hover { 
            background: rgba(0,170,255,0.15); 
            border-color: rgba(0,170,255,0.5); 
        }
        .speed-presets button.active { 
            background: rgba(0,170,255,0.25); 
            border-color: rgba(0,170,255,0.8); 
            color: #fff; 
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: var(--slider-track-color);
            border-radius: 5px;
            outline: none;
            padding: 0;
            margin: 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--slider-thumb-color);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid var(--ui-bg-color);
            transition: background 0.2s;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--slider-thumb-color);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid var(--ui-bg-color);
        }
        
        #timeline {
            margin-top: 20px;
        }
        #timeline label {
            font-weight: bold;
        }

        #webgpu-error {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #ff3333;
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.2em;
        }
    </style>
</head>
<body>

    <!-- Cinematic starfield background canvas -->
    <canvas id="bg-canvas"></canvas>
    <canvas id="webgpu-canvas"></canvas>

    <div id="ui-container">
        <h1>Dynamic Earth Controls - By Nacef</h1>
        <div class="ui-control">
            <label for="speed-slider">Animation Speed</label>
            <input type="range" id="speed-slider" min="0" max="5" value="1" step="0.1">
        </div>
        <div class="ui-control">
            <label for="plate-speed-slider">Plate Speed (cm/yr)</label>
            <input type="range" id="plate-speed-slider" min="0" max="15" value="5" step="0.1">
            <div id="plate-speed-presets" class="speed-presets">
                <!-- Realistic presets from geology literature: ~0–10 cm/yr typical, up to ~10–12 fast -->
                <button type="button" data-value="0" title="Dormant (locked) or intraplate">0</button>
                <button type="button" data-value="1" title="Very slow (cratonic interiors)">1</button>
                <button type="button" data-value="2" title="Slow plates (e.g., Eurasian/North American)">2</button>
                <button type="button" data-value="3" title="Slow–moderate (e.g., Africa/South America segments)">3</button>
                <button type="button" data-value="4" title="Moderate (common)">4</button>
                <button type="button" data-value="5" title="Moderate–active">5</button>
                <button type="button" data-value="6" title="Active boundaries (Indian/Australian)">6</button>
                <button type="button" data-value="8" title="Fast (Pacific boundary segments)">8</button>
                <button type="button" data-value="10" title="Very fast (rare upper range)">10</button>
                <button type="button" data-value="12" title="Exceptional fast (upper observed)">12</button>
            </div>
        </div>
        <div class="ui-control">
            <label for="clouds-opacity-slider">Clouds Opacity</label>
            <input type="range" id="clouds-opacity-slider" min="0" max="1" value="0.6" step="0.01">
        </div>
        <div class="ui-control">
            <label for="roughness-slider">Surface Roughness</label>
            <input type="range" id="roughness-slider" min="0.2" max="1.0" value="0.85" step="0.01">
        </div>
        <div class="ui-control">
            <label for="viscosity-slider">Mantle Viscosity (relative)</label>
            <input type="range" id="viscosity-slider" min="19" max="22" value="20" step="0.1">
        </div>
        <div class="ui-control">
            <label for="boundary-gain-slider">Boundary Emphasis</label>
            <input type="range" id="boundary-gain-slider" min="0.5" max="3.0" value="1.0" step="0.1">
        </div>
        <div class="ui-control">
            <label for="complexity-slider">Flow Complexity</label>
            <input type="range" id="complexity-slider" min="1.0" max="8.0" value="3.0" step="0.1">
        </div>
        <div id="timeline" class="ui-control">
            <label for="time-slider">Simulation Timeline</label>
            <input type="range" id="time-slider" min="0" max="1000" value="0" step="1">
        </div>
    </div>

    <div id="webgpu-error">
        <h2>WebGPU Not Supported</h2>
        <p>This experience requires a browser with WebGPU support. Please enable it or use a modern browser like Chrome or Edge.</p>
    </div>

    <!-- Map bare imports (e.g., 'three') to CDN so example modules resolve -->
    <script async src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
      }
    }
    </script>

    <!-- JAVASCRIPT: All application logic is embedded here. -->
    <script type="module">
        // Import necessary Three.js modules from a CDN
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/controls/OrbitControls.js';
        import WebGPURenderer from 'https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/renderers/webgpu/WebGPURenderer.js';
        import WebGPU from 'https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/capabilities/WebGPU.js';
        import {
            tslFn, uniform, texture, smoothstep,
            positionLocal, modelWorldMatrix,
            vec3, vec4, color, length, mix, sin,
            triNoise3D,
            MeshStandardNodeMaterial, MeshPhysicalNodeMaterial
        } from 'https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/nodes/Nodes.js';

        // --- CORE INITIALIZATION ---
        
        // 1. WebGPU availability (do not hard-fail; we can force WebGL for transparency)
        const hasWebGPU = WebGPU.isAvailable();

        // --- GLOBAL VARIABLES & CONSTANTS ---
        
        let scene, camera, renderer, controls, clock;
        let useNodeMaterials = true; // will be disabled when using WebGL fallback
        let starBase, starMilky; // THREE.Points groups
        let starBaseData = null, starMilkyData = null; // per-star twinkle data
        let mantle, crust, clouds;
        let earthMaterial; // promote to global for LOD swaps
        let hiRequested = false, hiReady = false;
        const plates = [];
        const CRUST_RADIUS = 1.01;
        const MANTLE_RADIUS = 1.0;
        
        // Simulation state
        let simulationTime = 0;
        let animationSpeed = 1;
        
        // GeoJSON data for plate boundaries, embedded directly.
        const plateData = {
          "type": "FeatureCollection",
          "features": [
            { "type": "Feature", "properties": {}, "geometry": { "type": "LineString", "coordinates": [ [-120, 60], [-110, 40], [-120, 20], [-110, 0], [-120, -20], [-110, -40] ] } },
            { "type": "Feature", "properties": {}, "geometry": { "type": "LineString", "coordinates": [ [-50, 50], [-40, 30], [-50, 10], [-40, -10], [-50, -30] ] } },
            { "type": "Feature", "properties": {}, "geometry": { "type": "LineString", "coordinates": [ [30, 60], [40, 40], [30, 20], [40, 0], [30, -20], [40, -40] ] } },
            { "type": "Feature", "properties": {}, "geometry": { "type": "LineString", "coordinates": [ [100, 50], [90, 30], [100, 10], [90, -10], [100, -30] ] } },
            { "type": "Feature", "properties": {}, "geometry": { "type": "LineString", "coordinates": [ [-170, 20], [-150, 15], [-170, 0], [-150, -15], [-170, -20] ] } }
          ]
        };

        // --- SHADER LOGIC (TSL) ---
        // This is the heart of the visualization, defining procedural noise, curl, and divergence.
        
        // Use built-in triNoise3D from Nodes instead of embedding GLSL.
        
        // Define shared uniforms for both materials
        const u_time = uniform(0);
        const u_frequency = uniform(3.0);
        // Realism controls (node uniforms)
        const u_eps = uniform(0.01);                 // sampling epsilon (affects smoothness)
        const u_boundaryGain = uniform(1.0);         // amplifies divergence for boundary emphasis
        const u_divThreshold = uniform(1.5);         // divergence threshold for coloring
        
        // A TSL function to calculate the curl of a potential field.
        // This creates a divergence-free (non-compressing) velocity field, perfect for fluid-like motion.
        const curlNoiseTSL = tslFn(([position]) => {
            const e = u_eps; // Small offset for finite differences (uniform-controlled)

            // Sample noise at 6 points around the current position to get partial derivatives
            // of a potential noise field.
            let dx = triNoise3D(position.add(vec3(0, e, 0)), 1.0, u_time.mul(0.05)).sub(
                     triNoise3D(position.sub(vec3(0, e, 0)), 1.0, u_time.mul(0.05)));
            let dy = triNoise3D(position.add(vec3(0, 0, e)), 1.0, u_time.mul(0.05)).sub(
                     triNoise3D(position.sub(vec3(0, 0, e)), 1.0, u_time.mul(0.05)));
            let dz = triNoise3D(position.add(vec3(e, 0, 0)), 1.0, u_time.mul(0.05)).sub(
                     triNoise3D(position.sub(vec3(e, 0, 0)), 1.0, u_time.mul(0.05)));

            // The curl is calculated from these derivatives
            return vec3(dy, dz, dx);
        });
        
        // --- MATERIALS ---

        function createMantleMaterial() {
            if (!useNodeMaterials) {
                // WebGL fallback: standard material under semi-transparent crust
                return new THREE.MeshStandardMaterial({
                    color: new THREE.Color(0x1b2033),
                    roughness: 0.85,
                    metalness: 0.0
                });
            }

            const material = new MeshStandardNodeMaterial();
            material.metalness = 0.0;
            material.roughness = 0.8;

            // TSL node graph for the mantle's appearance
            material.colorNode = tslFn(() => {
                // Calculate position in world space to apply noise
                const worldPosition = modelWorldMatrix.mul(vec4(positionLocal, 1.0)).xyz;

                // Create a 4D noise input: 3D position + time
                const noisePos = worldPosition.mul(u_frequency);
                const timeVec = vec3(u_time.mul(0.05));
                
                // Use two animated curl noise fields, scrolled in opposite directions,
                // and add them together for more complex motion.
                const velocity1 = curlNoiseTSL(noisePos.add(timeVec));
                const velocity2 = curlNoiseTSL(noisePos.sub(timeVec));
                const totalVelocity = velocity1.add(velocity2);
                
                // Color is based on the magnitude (speed) of the flow
                const speed = length(totalVelocity);
                
                // Define a color ramp: Dark Blue -> Red -> Yellow -> White
                const c1 = color("#000033"); // Deep space blue
                const c2 = color("#ff4500"); // OrangeRed
                const c3 = color("#ffff00"); // Yellow
                const c4 = color("#ffffff"); // White
                
                // Interpolate through the colors based on speed
                const stage1 = mix(c1, c2, smoothstep(0.0, 0.7, speed));
                const stage2 = mix(stage1, c3, smoothstep(0.7, 1.2, speed));
                const finalColor = mix(stage2, c4, smoothstep(1.2, 1.8, speed));
                
                return finalColor;
            })();

            return material;
        }

        function createCrustMaterial() {
            const material = new MeshPhysicalNodeMaterial();
            // These properties create the semi-transparent, glass-like effect
            material.transmission = uniform(0.25);
            material.thickness = uniform(0.2);
            material.roughness = 0.2;
            material.ior = 1.3;
            material.specularIntensity = 0.5;

            // This TSL graph calculates divergence to show ridges and subduction zones
            material.colorNode = tslFn(() => {
                const worldPosition = modelWorldMatrix.mul(vec4(positionLocal, 1.0)).xyz;
                const timeVec = vec3(u_time.mul(0.05));
                const noisePos = (pos) => pos.mul(u_frequency);

                // Helper function to get velocity at any point
                const getVelocity = (pos) => {
                    const velocity1 = curlNoiseTSL(noisePos(pos).add(timeVec));
                    const velocity2 = curlNoiseTSL(noisePos(pos).sub(timeVec));
                    return velocity1.add(velocity2);
                };

                const e = u_eps.mul(8.0); // Epsilon for divergence calculation (scaled)
                
                // Sample the *velocity* field at 6 neighboring points
                const v_px = getVelocity(worldPosition.add(vec3(e, 0, 0)));
                const v_nx = getVelocity(worldPosition.sub(vec3(e, 0, 0)));
                const v_py = getVelocity(worldPosition.add(vec3(0, e, 0)));
                const v_ny = getVelocity(worldPosition.sub(vec3(0, e, 0)));
                const v_pz = getVelocity(worldPosition.add(vec3(0, 0, e)));
                const v_nz = getVelocity(worldPosition.sub(vec3(0, 0, e)));

                // Compute partial derivatives of velocity components
                const dvx_dx = v_px.x.sub(v_nx.x).div(2.0 * e);
                const dvy_dy = v_py.y.sub(v_ny.y).div(2.0 * e);
                const dvz_dz = v_pz.z.sub(v_nz.z).div(2.0 * e);

                // Divergence = dvx/dx + dvy/dy + dvz/dz
                const divergence = dvx_dx.add(dvy_dy).add(dvz_dz);

                // Define colors
                const baseColor = color("#a08c7a"); // Earthy brown/tan
                const ridgeColor = color("#ff5500"); // Fiery orange-red for spreading ridges
                const trenchColor = color("#3b0078"); // Deep purple-blue for subduction trenches

                // Blend colors based on divergence
                // Positive divergence (spreading) -> mix in ridge color
                // Negative divergence (converging) -> mix in trench color
                const divergenceThreshold = u_divThreshold;
                let finalColor = baseColor;
                finalColor = mix(finalColor, ridgeColor, smoothstep(0.1, divergenceThreshold, divergence.mul(u_boundaryGain)));
                finalColor = mix(finalColor, trenchColor, smoothstep(0.1, divergenceThreshold, divergence.negate().mul(u_boundaryGain)));
                
                return finalColor;
            })();

            return material;
        }

        // --- CPU-SIDE SIMULATION LOGIC ---
        // A re-implementation of the curl noise logic in JS to drive plate advection on the CPU.
        
        // Standalone JS implementation of the noise function for CPU calculations
        class NoiseGenerator {
            constructor() {
                // Ported constants from GLSL
                this.p = new Uint8Array(512);
                const permutation = [ 151,160,137,91,90,15,
                131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
                190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
                88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
                77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
                102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
                135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
                5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
                223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
                129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
                251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
                49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
                138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180
                ];
                for (let i=0; i < 256; i++) this.p[i] = this.p[i+256] = permutation[i];
            }
            
            // Minimal JS port of snoise
            snoise(v) {
                // ... This is a complex function. For this demo, we'll use a simpler
                // CPU-side noise approach to avoid a lengthy port. We will use Math.random()
                // seeded for deterministic but simple noise. The GPU-side noise remains high quality.
                // A full port is possible but extremely verbose. Let's use a proxy.
                // A better approach for true consistency is a Web Worker with an offscreen canvas
                // running the GLSL shader to read back values, but that adds complexity and async issues.
                
                // Simplified proxy noise function for CPU advection
                const x = v.x, y = v.y, z = v.z;
                const fx = Math.floor(x), fy = Math.floor(y), fz = Math.floor(z);
                let n = fx * 31 + fy * 57 + fz * 71;
                n = (n << 13) ^ n;
                n = (n * (n * n * 15731 + 789221) + 1376312589);
                return 1.0 - ((n & 0x7fffffff) / 1073741824.0);
            }

            calculateCurl(p, frequency, time) {
                // Tie CPU-side sampling epsilon to the UI-controlled uniform
                const e = 0.1 * (u_eps.value / 0.01);
                const p_in = p.clone().multiplyScalar(frequency).addScalar(time * 0.05);

                const dx = this.snoise(p_in.clone().add(new THREE.Vector3(0, e, 0))) - this.snoise(p_in.clone().sub(new THREE.Vector3(0, e, 0)));
                const dy = this.snoise(p_in.clone().add(new THREE.Vector3(0, 0, e))) - this.snoise(p_in.clone().sub(new THREE.Vector3(0, 0, e)));
                const dz = this.snoise(p_in.clone().add(new THREE.Vector3(e, 0, 0))) - this.snoise(p_in.clone().sub(new THREE.Vector3(e, 0, 0)));
                
                // Combine curl noise fields for complexity
                const curl1 = new THREE.Vector3(dy, dz, dx);

                const p_in2 = p.clone().multiplyScalar(frequency).addScalar(-time * 0.05);
                const dx2 = this.snoise(p_in2.clone().add(new THREE.Vector3(0, e, 0))) - this.snoise(p_in2.clone().sub(new THREE.Vector3(0, e, 0)));
                const dy2 = this.snoise(p_in2.clone().add(new THREE.Vector3(0, 0, e))) - this.snoise(p_in2.clone().sub(new THREE.Vector3(0, 0, e)));
                const dz2 = this.snoise(p_in2.clone().add(new THREE.Vector3(e, 0, 0))) - this.snoise(p_in2.clone().sub(new THREE.Vector3(e, 0, 0)));

                const curl2 = new THREE.Vector3(dy2, dz2, dx2);
                
                return curl1.add(curl2);
            }
        }
        const cpuNoise = new NoiseGenerator();
        
        // --- SCENE SETUP ---

        function init() {
            // Scene
            scene = new THREE.Scene();
            
            // Camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 3.5);

            // Renderer
            const canvas = document.querySelector('#webgpu-canvas');
            // Force WebGL for reliable alpha compositing over 2D background
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true, powerPreference: 'high-performance' });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Make renderer background transparent; let bg-canvas paint space
            renderer.setClearColor(0x000814, 0);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 2.80; // slightly brighter overall
            if (THREE && THREE.SRGBColorSpace) {
                renderer.outputColorSpace = THREE.SRGBColorSpace;
            }
            useNodeMaterials = false;

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.minDistance = 1.5;
            controls.maxDistance = 10;

            // Clock
            clock = new THREE.Clock();

            // Lighting
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            scene.add(new THREE.HemisphereLight(0x88aaff, 0x091428, 0.35));
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
            sunLight.position.set(5, 3, 5);
            scene.add(sunLight);

            // Starfield (3D Points) inside the scene
            addStarfield3D();

            // Earth Model
            // Mantle
            const mantleGeometry = new THREE.SphereGeometry(MANTLE_RADIUS, 64, 32);
            const mantleMaterial = createMantleMaterial();
            mantle = new THREE.Mesh(mantleGeometry, mantleMaterial);
            scene.add(mantle);

            // Earth Surface (textured)
            const loader = new THREE.TextureLoader();
            const earthMap = loader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg');
            const normalMap = loader.load('https://threejs.org/examples/textures/planets/earth_normal_2048.jpg');
            const nightMap = loader.load('https://threejs.org/examples/textures/planets/earth_lights_2048.png');
            const cloudsMap = loader.load('https://threejs.org/examples/textures/planets/earth_clouds_1024.png');

            earthMap.colorSpace = THREE.SRGBColorSpace;
            nightMap.colorSpace = THREE.SRGBColorSpace;
            cloudsMap.colorSpace = THREE.SRGBColorSpace;
            // Improve texture sampling quality when zoomed (anisotropy + mipmaps)
            const maxAniso = renderer.capabilities.getMaxAnisotropy ? renderer.capabilities.getMaxAnisotropy() : 8;
            ;[earthMap, normalMap, nightMap, cloudsMap].forEach(t => {
                if (!t) return;
                t.anisotropy = maxAniso;
                t.generateMipmaps = true;
                t.minFilter = THREE.LinearMipmapLinearFilter;
                t.magFilter = THREE.LinearFilter;
                t.needsUpdate = true;
            });

            const crustGeometry = new THREE.SphereGeometry(CRUST_RADIUS, 256, 128);
            earthMaterial = new THREE.MeshPhysicalMaterial({
                map: earthMap,
                normalMap: normalMap,
                roughness: 0.8,
                metalness: 0.0,
                transparent: true,
                opacity: 0.9,
                emissive: new THREE.Color(0x111111),
                emissiveMap: nightMap,
                emissiveIntensity: 0.28
            });
            // Enhance material response for finer detail
            earthMaterial.normalScale = new THREE.Vector2(1.25, 1.25);
            earthMaterial.clearcoat = 0.15;
            earthMaterial.clearcoatRoughness = 0.4;
            crust = new THREE.Mesh(crustGeometry, earthMaterial);
            scene.add(crust);

            // Clouds layer
            const cloudsGeometry = new THREE.SphereGeometry(CRUST_RADIUS + 0.003, 128, 64);
            const cloudsMaterial = new THREE.MeshStandardMaterial({
                map: cloudsMap,
                transparent: true,
                opacity: 0.5,
                depthWrite: false
            });
            clouds = new THREE.Mesh(cloudsGeometry, cloudsMaterial);
            scene.add(clouds);
            
            // Plate Boundaries
            const plateMaterial = new THREE.MeshBasicMaterial({ color: 0xF77F00  , transparent: true, opacity: 0.7 });
            plateData.features.forEach(feature => {
                const points = feature.geometry.coordinates.map(coord => {
                    const lon = coord[0];
                    const lat = coord[1];
                    const phi = (90 - lat) * (Math.PI / 180);
                    const theta = (lon + 180) * (Math.PI / 180);

                    const x = -CRUST_RADIUS * Math.sin(phi) * Math.cos(theta);
                    const y = CRUST_RADIUS * Math.cos(phi);
                    const z = CRUST_RADIUS * Math.sin(phi) * Math.sin(theta);
                    return new THREE.Vector3(x, y, z);
                });

                const curve = new THREE.CatmullRomCurve3(points);
                const tubeGeometry = new THREE.TubeGeometry(curve, 64, 0.01, 8, false);
                const tubeMesh = new THREE.Mesh(tubeGeometry, plateMaterial);
                scene.add(tubeMesh);

                // Store original positions for advection calculation
                plates.push({
                    mesh: tubeMesh,
                    originalPositions: tubeMesh.geometry.attributes.position.clone()
                });
            });

            // UI Listeners
            setupUI();

            // Handle window resizing
            window.addEventListener('resize', onWindowResize, false);
        }

        // Physical-ish parameters
        let plateSpeedCmYr = 5.0; // default realistic average
        let advectionScale = 0.0005 * (plateSpeedCmYr / 5.0);

        function setupUI() {
            const speedSlider = document.getElementById('speed-slider');
            const plateSpeedSlider = document.getElementById('plate-speed-slider');
            const plateSpeedPresets = document.querySelectorAll('#plate-speed-presets button[data-value]');
            const cloudsOpacitySlider = document.getElementById('clouds-opacity-slider');
            const roughnessSlider = document.getElementById('roughness-slider');
            const viscositySlider = document.getElementById('viscosity-slider');
            const boundaryGainSlider = document.getElementById('boundary-gain-slider');
            const complexitySlider = document.getElementById('complexity-slider');
            const timeSlider = document.getElementById('time-slider');
            const timelineLabel = document.querySelector('#timeline label[for="time-slider"]');

            // Helper to update the timeline label with years
            const updateTimelineLabel = (years) => {
                if (!timelineLabel) return;
                const y = Math.round(Number(years) || 0);
                timelineLabel.textContent = `Simulation Timeline (${y} years)`;
            };
            
            speedSlider.addEventListener('input', (e) => animationSpeed = parseFloat(e.target.value));
            
            plateSpeedSlider.addEventListener('input', (e) => {
                plateSpeedCmYr = parseFloat(e.target.value);
                // Calibrate so 5 cm/yr matches previous visual speed
                advectionScale = 0.0005 * (plateSpeedCmYr / 5.0);
                // Update active preset highlight
                plateSpeedPresets.forEach(b => b.classList.toggle('active', Math.abs(parseFloat(b.dataset.value) - plateSpeedCmYr) < 0.05));
            });

            // Preset buttons -> set slider and recompute scale
            plateSpeedPresets.forEach(btn => {
                btn.addEventListener('click', () => {
                    const v = parseFloat(btn.dataset.value);
                    plateSpeedSlider.value = v.toString();
                    plateSpeedSlider.dispatchEvent(new Event('input', { bubbles: true }));
                });
            });

            // Initialize preset highlight
            plateSpeedPresets.forEach(b => b.classList.toggle('active', Math.abs(parseFloat(b.dataset.value) - parseFloat(plateSpeedSlider.value)) < 0.05));

            cloudsOpacitySlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                if (clouds && clouds.material) clouds.material.opacity = value;
            });

            roughnessSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                if (crust && crust.material) crust.material.roughness = value;
            });

            complexitySlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                // Update shared node-uniform used by both materials
                u_frequency.value = value;
            });

            timeSlider.addEventListener('input', (e) => {
                simulationTime = parseFloat(e.target.value);
                // Stop automatic animation while scrubbing
                if (animationSpeed > 0) speedSlider.value = 0;
                animationSpeed = 0;
                updateTimelineLabel(simulationTime);
            });

            // Initialize label with current slider value
            updateTimelineLabel(timeSlider.value);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            if (renderer.setPixelRatio) renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- HIGH-RES TEXTURE LOD (optional local assets) ---
        const textureLoader = new THREE.TextureLoader();
        function loadTextureSequence(urls) {
            return new Promise((resolve, reject) => {
                let i = 0;
                const tryNext = () => {
                    if (i >= urls.length) return reject(new Error('No candidate textures found'));
                    const url = urls[i++];
                    textureLoader.load(url, tex => resolve(tex), undefined, () => tryNext());
                };
                tryNext();
            });
        }

        // --- BACKGROUND STARFIELD (Canvas 2D) ---
        let bgCtx, bgCanvas, bgStars = [], bgMilkyStars = [], bgNebulas = [], bgMilkyPatches = [];
        function initBackground() {
            bgCanvas = document.getElementById('bg-canvas');
            bgCtx = bgCanvas.getContext('2d');
            resizeBackground();
            createStarfield();
            createMilkyWay();
            createNebulas();
            window.addEventListener('resize', resizeBackground);
        }

        function resizeBackground() {
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            const w = Math.floor(window.innerWidth * dpr);
            const h = Math.floor(window.innerHeight * dpr);
            if (bgCanvas.width !== w || bgCanvas.height !== h) {
                bgCanvas.width = w;
                bgCanvas.height = h;
            }
        }

        function addStarfield3D() {
            const baseCount = Math.floor((window.innerWidth * window.innerHeight) / 4000); // hundreds
            const milkyCount = Math.floor((window.innerWidth * window.innerHeight) / 3000);
            const R1 = 180, R2 = 220; // radii for parallax feel

            function randOnSphere(radius) {
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);
                return new THREE.Vector3(x, y, z);
            }

            function gaussian() {
                let u = 0, v = 0;
                while (u === 0) u = Math.random();
                while (v === 0) v = Math.random();
                return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            }

            // Base stars (uniform sphere)
            const pos1 = new Float32Array(baseCount * 3);
            const col1 = new Float32Array(baseCount * 3);
            const tw1 = new Float32Array(baseCount);
            const off1 = new Float32Array(baseCount);
            for (let i = 0; i < baseCount; i++) {
                const p = randOnSphere(R1 + Math.random() * 40);
                pos1[i*3+0] = p.x; pos1[i*3+1] = p.y; pos1[i*3+2] = p.z;
                const base = 0.5 + Math.random() * 0.5;
                col1[i*3+0] = base; col1[i*3+1] = base; col1[i*3+2] = base;
                tw1[i] = 0.5 + Math.random() * 1.5;
                off1[i] = Math.random() * Math.PI * 2;
            }
            const geo1 = new THREE.BufferGeometry();
            geo1.setAttribute('position', new THREE.BufferAttribute(pos1, 3));
            geo1.setAttribute('color', new THREE.BufferAttribute(col1, 3));
            const mat1 = new THREE.PointsMaterial({ size: 1.3, sizeAttenuation: true, vertexColors: true, depthWrite: false, transparent: true });
            starBase = new THREE.Points(geo1, mat1);
            scene.add(starBase);
            starBaseData = { tw: tw1, off: off1, colors: col1, geometry: geo1 };

            // Milky Way band
            // Define band plane by normal n (tilt ~22deg around X axis) and basis (u,v)
            const tilt = THREE.MathUtils.degToRad(22);
            const n = new THREE.Vector3(0, Math.sin(tilt), Math.cos(tilt)).normalize();
            const uAxis = new THREE.Vector3().crossVectors(n, new THREE.Vector3(1,0,0)).normalize();
            const vAxis = new THREE.Vector3().crossVectors(n, uAxis).normalize();
            const bandSigma = 0.25; // radians thickness

            const pos2 = new Float32Array(milkyCount * 3);
            const col2 = new Float32Array(milkyCount * 3);
            const tw2 = new Float32Array(milkyCount);
            const off2 = new Float32Array(milkyCount);
            for (let i = 0; i < milkyCount; i++) {
                const t = Math.random() * Math.PI * 2; // along band
                const d = gaussian() * bandSigma;      // cross-band offset
                const dir = new THREE.Vector3()
                    .addScaledVector(uAxis, Math.cos(t))
                    .addScaledVector(vAxis, Math.sin(t))
                    .addScaledVector(n, d)
                    .normalize();
                const r = R2 + Math.random() * 40;
                const p = dir.multiplyScalar(r);
                pos2[i*3+0] = p.x; pos2[i*3+1] = p.y; pos2[i*3+2] = p.z;
                const base = 0.7 + Math.random() * 0.5;
                col2[i*3+0] = base; col2[i*3+1] = base; col2[i*3+2] = base;
                tw2[i] = 0.6 + Math.random() * 1.2;
                off2[i] = Math.random() * Math.PI * 2;
            }
            const geo2 = new THREE.BufferGeometry();
            geo2.setAttribute('position', new THREE.BufferAttribute(pos2, 3));
            geo2.setAttribute('color', new THREE.BufferAttribute(col2, 3));
            const mat2 = new THREE.PointsMaterial({ size: 1.6, sizeAttenuation: true, vertexColors: true, depthWrite: false, transparent: true });
            starMilky = new THREE.Points(geo2, mat2);
            scene.add(starMilky);
            starMilkyData = { tw: tw2, off: off2, colors: col2, geometry: geo2 };
        }

        function updateStarfield3D(t) {
            function updateSet(data, intensityBase=0.6, intensityVar=0.4) {
                if (!data) return;
                const { tw, off, colors, geometry } = data;
                for (let i = 0; i < tw.length; i++) {
                    const twk = 0.5 + 0.5 * Math.sin(t * 0.8 * tw[i] + off[i]);
                    const I = intensityBase + intensityVar * twk; // 0..1
                    colors[i*3+0] = I;
                    colors[i*3+1] = I;
                    colors[i*3+2] = I;
                }
                geometry.attributes.color.needsUpdate = true;
            }
            // Slightly dim 3D stars so 2D Milky Way stands out
            updateSet(starBaseData, 0.38, 0.50);
            updateSet(starMilkyData, 0.52, 0.38);
        }

        function createStarfield() {
            bgStars = [];
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            const area = window.innerWidth * window.innerHeight;
            const count = Math.floor(area / 6000); // base field: hundreds
            for (let i = 0; i < count; i++) {
                const layer = Math.random(); // parallax depth 0..1
                bgStars.push({
                    x: Math.random() * bgCanvas.width,
                    y: Math.random() * bgCanvas.height,
                    r: (Math.random() * 0.9 + 0.2) * dpr * (0.5 + layer),
                    baseA: 0.25 + Math.random() * 0.6,
                    tw: 0.4 + Math.random() * 1.6, // twinkle speed
                    off: Math.random() * Math.PI * 2,
                    hue: 190 + Math.random() * 100, // varied blue-white
                    layer
                });
            }
        }

        function createMilkyWay() {
            bgMilkyStars = [];
            bgMilkyPatches = [];
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            const w = bgCanvas.width, h = bgCanvas.height;
            const area = window.innerWidth * window.innerHeight;
            const count = Math.floor(area / 4500); // denser band
            const angle = Math.PI * 0.38; // ~22 degrees
            const cx = w * 0.5, cy = h * 0.55;
            const L = Math.max(w, h) * 1.2; // band length
            const nx = Math.cos(angle), ny = Math.sin(angle);
            const px = -ny, py = nx; // perpendicular unit

            function randn() {
                // Box-Muller
                let u = 0, v = 0;
                while (u === 0) u = Math.random();
                while (v === 0) v = Math.random();
                return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            }

            const sigma = 0.18 * Math.min(w, h); // band thickness
            for (let i = 0; i < count; i++) {
                const t = (Math.random() * 2 - 1) * (L * 0.5);
                let d = randn() * sigma; // cross-track offset
                let x = cx + nx * t + px * d;
                let y = cy + ny * t + py * d;
                if (x < -50 || x > w + 50 || y < -50 || y > h + 50) { i--; continue; }

                const layer = 0.3 + Math.random() * 0.5; // milky band mid-depth
                bgMilkyStars.push({
                    x, y,
                    r: (Math.random() * 1.2 + 0.3) * dpr * (0.6 + layer),
                    baseA: 0.35 + Math.random() * 0.5,
                    tw: 0.6 + Math.random() * 1.2,
                    off: Math.random() * Math.PI * 2,
                    hue: 210 + Math.random() * 40,
                    layer,
                });
            }

            // soft dust patches along the band
            const patchCount = 6;
            for (let i = 0; i < patchCount; i++) {
                const t = (i / (patchCount - 1) - 0.5) * L * 0.8;
                const d = (Math.random() * 0.2 - 0.1) * sigma;
                const x = cx + nx * t + px * d;
                const y = cy + ny * t + py * d;
                const r = (0.25 + Math.random() * 0.2) * Math.min(w, h);
                const color = `rgba(200,220,255,${0.06 + Math.random() * 0.05})`;
                bgMilkyPatches.push({ x, y, r, color });
            }
        }

        function createNebulas() {
            // A few soft colored glows (boosted visibility)
            bgNebulas = [
                { x: 0.14, y: 0.22, r: 360, color: 'rgba(40,130,255,0.20)' },
                { x: 0.86, y: 0.20, r: 300, color: 'rgba(200,60,255,0.18)' },
                { x: 0.28, y: 0.78, r: 340, color: 'rgba(0,220,180,0.16)' }
            ];
        }

        function drawBackground(t) {
            if (!bgCtx) return;
            const w = bgCanvas.width, h = bgCanvas.height;
            // Space base
            bgCtx.fillStyle = '#000814';
            bgCtx.fillRect(0, 0, w, h);
            // Nebula glows (lighter blending)
            bgCtx.globalCompositeOperation = 'lighter';
            bgNebulas.forEach((n, i) => {
                const dx = Math.sin((t * 0.00008) + i) * 40;
                const dy = Math.cos((t * 0.00006) + i * 1.7) * 40;
                const gx = bgCtx.createRadialGradient(
                    n.x * w + dx, n.y * h + dy, 0,
                    n.x * w + dx, n.y * h + dy, n.r
                );
                gx.addColorStop(0, n.color);
                gx.addColorStop(1, 'rgba(0,0,0,0)');
                bgCtx.fillStyle = gx;
                bgCtx.beginPath();
                bgCtx.arc(n.x * w + dx, n.y * h + dy, n.r, 0, Math.PI * 2);
                bgCtx.fill();
            });

            // Milky Way continuous band (glow)
            (function drawMilkyBand() {
                const angle = Math.PI * 0.38; // ~22 degrees
                const cx = w * 0.5, cy = h * 0.55;
                const L = Math.max(w, h) * 1.4; // a bit longer than screen
                const nx = Math.cos(angle), ny = Math.sin(angle);
                const px = -ny, py = nx;
                const steps = 24;
                bgCtx.globalCompositeOperation = 'lighter';
                for (let i = 0; i < steps; i++) {
                    const tnorm = (i / (steps - 1)) - 0.5;
                    const t = tnorm * L;
                    const jitter = (Math.sin((t + tnorm * 13) * 0.0007) * 0.12 + (Math.random() - 0.5) * 0.06);
                    const d = jitter * Math.min(w, h) * 0.22;
                    const x = cx + nx * t + px * d;
                    const y = cy + ny * t + py * d;
                    const r = Math.min(w, h) * (0.18 + Math.random() * 0.08);
                    const core = `rgba(230,240,255,0.08)`;
                    const edge = 'rgba(0,0,0,0)';
                    const g = bgCtx.createRadialGradient(x, y, 0, x, y, r);
                    g.addColorStop(0.0, core);
                    g.addColorStop(1.0, edge);
                    bgCtx.fillStyle = g;
                    bgCtx.beginPath();
                    bgCtx.arc(x, y, r, 0, Math.PI * 2);
                    bgCtx.fill();
                }
            })();

            // Milky Way dust patches (brightened)
            bgMilkyPatches.forEach((p, i) => {
                const shift = Math.sin((t * 0.00005) + i) * (p.r * 0.05);
                const gx = bgCtx.createRadialGradient(
                    p.x + shift, p.y - shift, 0,
                    p.x + shift, p.y - shift, p.r
                );
                // Slightly boost dust opacity for visibility
                const col = p.color.replace(/rgba\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/, (m, r,g,b,a) => `rgba(${r},${g},${b},${Math.min(parseFloat(a) + 0.05, 0.25)})`);
                gx.addColorStop(0, col);
                gx.addColorStop(1, 'rgba(0,0,0,0)');
                bgCtx.fillStyle = gx;
                bgCtx.beginPath();
                bgCtx.arc(p.x + shift, p.y - shift, p.r, 0, Math.PI * 2);
                bgCtx.fill();
            });
            // Stars
            bgCtx.globalCompositeOperation = 'screen';
            const drift = t * 0.01;
            for (const s of bgStars) {
                const twinkle = 0.5 + 0.5 * Math.sin(t * 0.002 * s.tw + s.off);
                const alpha = s.baseA * (0.6 + 0.4 * twinkle);
                const parallax = 0.08 + 0.6 * s.layer;
                const x = (s.x - drift * parallax) % w;
                const y = s.y;
                bgCtx.fillStyle = `hsla(${s.hue}, 80%, ${70 + s.layer * 20}%, ${alpha})`;
                bgCtx.beginPath();
                bgCtx.arc(x < 0 ? x + w : x, y, s.r, 0, Math.PI * 2);
                bgCtx.fill();
            }

            // Milky Way denser star band
            for (const s of bgMilkyStars) {
                const twinkle = 0.5 + 0.5 * Math.sin(t * 0.003 * s.tw + s.off);
                const alpha = s.baseA * (0.7 + 0.3 * twinkle);
                const parallax = 0.12 + 0.5 * s.layer;
                const x = (s.x - drift * parallax) % w;
                const y = s.y;
                bgCtx.fillStyle = `hsla(${s.hue}, 70%, ${78 + s.layer * 12}%, ${alpha})`;
                bgCtx.beginPath();
                bgCtx.arc(x < 0 ? x + w : x, y, s.r, 0, Math.PI * 2);
                bgCtx.fill();
            }
            bgCtx.globalCompositeOperation = 'source-over';
        }

        function startBackgroundAnimation() {
            function loop(t) {
                drawBackground(t || 0);
                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);
        }

        // --- ANIMATION LOOP ---
        
        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();
            
            // Update simulation time if playing
            if (animationSpeed > 0) {
                simulationTime += deltaTime * animationSpeed * 5; // Scale speed for better UI feel
                if(simulationTime > 1000) simulationTime = 0; // Loop timeline
                const ts = document.getElementById('time-slider');
                if (ts) ts.value = simulationTime;
                // Keep the label in sync during autoplay
                const timelineLabel = document.querySelector('#timeline label[for="time-slider"]');
                if (timelineLabel) {
                    const y = Math.round(Number(simulationTime) || 0);
                    timelineLabel.textContent = `Simulation Timeline (${y} years)`;
                }
            }
            
            // Update shader uniforms
            u_time.value = simulationTime * 0.1;
            
            // --- Plate Advection on CPU ---
            // This is a simplified advection model for performance. Instead of integrating the
            // path over time (which is slow for scrubbing), we calculate the total displacement
            // from the original position based on the current simulationTime.
            const advectionSpeed = advectionScale; 
            const freq = u_frequency.value;
            
            plates.forEach(plate => {
                const positions = plate.mesh.geometry.attributes.position;
                const originalPositions = plate.originalPositions;
                const count = positions.count;

                for (let i = 0; i < count; i++) {
                    const originalPos = new THREE.Vector3().fromBufferAttribute(originalPositions, i);
                    
                    // Calculate velocity at the original position offset by time
                    const velocity = cpuNoise.calculateCurl(originalPos, freq, simulationTime * 0.1);
                    
                    // Calculate total displacement
                    const displacement = velocity.multiplyScalar(simulationTime * advectionSpeed);
                    
                    // Apply displacement to original position
                    const newPos = originalPos.clone().add(displacement);
                    
                    // Ensure the new position remains on the sphere's surface
                    newPos.normalize().multiplyScalar(CRUST_RADIUS);
                    
                    positions.setXYZ(i, newPos.x, newPos.y, newPos.z);
                }
                positions.needsUpdate = true;
            });

            controls.update();
            // High-res texture LOD when zooming in close to the globe
            const dist = camera.position.length();
            if (!hiRequested && !hiReady && dist < 2.2 && earthMaterial) {
                hiRequested = true;
                Promise.all([
                    loadTextureSequence(['assets/earth/earth_albedo_8k.jpg','assets/earth/earth_albedo_8k.png','assets/earth/earth_albedo_4k.jpg']),
                    loadTextureSequence(['assets/earth/earth_normal_8k.jpg','assets/earth/earth_normal_8k.png','assets/earth/earth_normal_4k.jpg']),
                    loadTextureSequence(['assets/earth/earth_lights_8k.png','assets/earth/earth_lights_4k.png']),
                    loadTextureSequence(['assets/earth/earth_clouds_4k.png','assets/earth/earth_clouds_8k.png'])
                ]).then(([albedo, normal, lights, cloudsTex]) => {
                    // Color space & sampling
                    if (albedo.colorSpace !== undefined) albedo.colorSpace = THREE.SRGBColorSpace;
                    if (lights && lights.colorSpace !== undefined) lights.colorSpace = THREE.SRGBColorSpace;
                    if (cloudsTex && cloudsTex.colorSpace !== undefined) cloudsTex.colorSpace = THREE.SRGBColorSpace;
                    const maxAniso = renderer.capabilities.getMaxAnisotropy ? renderer.capabilities.getMaxAnisotropy() : 8;
                    [albedo, normal, lights, cloudsTex].forEach(t => {
                        if (!t) return;
                        t.anisotropy = maxAniso;
                        t.generateMipmaps = true;
                        t.minFilter = THREE.LinearMipmapLinearFilter;
                        t.magFilter = THREE.LinearFilter;
                        t.needsUpdate = true;
                    });
                    // Apply to materials
                    earthMaterial.map = albedo;
                    earthMaterial.normalMap = normal;
                    if (lights) earthMaterial.emissiveMap = lights;
                    earthMaterial.needsUpdate = true;
                    if (clouds && clouds.material && cloudsTex) {
                        clouds.material.map = cloudsTex;
                        clouds.material.needsUpdate = true;
                    }
                    hiReady = true;
                }).catch(() => {
                    // No local high-res textures found; keep base maps silently
                });
            }
            // Subtle cloud drift for realism
            if (clouds) clouds.rotation.y += 0.02 * deltaTime;
            // Update star twinkling
            updateStarfield3D(clock.getElapsedTime());
            if (renderer.renderAsync) renderer.renderAsync(scene, camera);
            else renderer.render(scene, camera);
        }

        // --- START THE APPLICATION ---
        // Initialize and animate the cinematic 2D starfield + Milky Way
        initBackground();
        startBackgroundAnimation();

        // Start 3D scene
        init();
        animate();

    </script>
</body>
</html>





